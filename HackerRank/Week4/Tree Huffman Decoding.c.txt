#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <assert.h>
#include <limits.h>
#include <stdbool.h>



typedef struct node {
    int freq;
    char data;
    struct node *left, *right;
} node;

typedef struct {
    int n, cap;
    node **a;
} heap;

int isLeaf(node *r) { return r->left == NULL && r->right == NULL; }

node* newNode(char c, int f, node *l, node *r) {
    node *n = (node*)malloc(sizeof(node));
    n->data = c;
    n->freq = f;
    n->left = l;
    n->right = r;
    return n;
}

heap* heap_new(int cap) {
    heap *h = (heap*)malloc(sizeof(heap));
    h->a = (node**)malloc(sizeof(node*) * cap);
    h->n = 0;
    h->cap = cap;
    return h;
}

void heap_swap(node **x, node **y) {
    node *t = *x;
    *x = *y;
    *y = t;
}

void heap_up(heap *h, int i) {
    while (i > 0) {
        int p = (i - 1) / 2;
        if (h->a[p]->freq <= h->a[i]->freq) break;
        heap_swap(&h->a[p], &h->a[i]);
        i = p;
    }
}

void heap_down(heap *h, int i) {
    for (;;) {
        int l = 2 * i + 1, r = 2 * i + 2, sm = i;
        if (l < h->n && h->a[l]->freq < h->a[sm]->freq) sm = l;
        if (r < h->n && h->a[r]->freq < h->a[sm]->freq) sm = r;
        if (sm == i) break;
        heap_swap(&h->a[i], &h->a[sm]);
        i = sm;
    }
}

void heap_push(heap *h, node *v) {
    if (h->n == h->cap) {
        h->cap *= 2;
        h->a = (node**)realloc(h->a, sizeof(node*) * h->cap);
    }
    h->a[h->n++] = v;
    heap_up(h, h->n - 1);
}

node* heap_pop(heap *h) {
    node *top = h->a[0];
    h->a[0] = h->a[--h->n];
    heap_down(h, 0);
    return top;
}

char* mydup(const char *s) {
    size_t n = strlen(s);
    char *d = (char*)malloc(n + 1);
    memcpy(d, s, n + 1);
    return d;
}

void build_codes(node *root, char *path, int d, char **codes) {
    if (isLeaf(root)) {
        path[d] = '\0';
        codes[(unsigned char)root->data] = mydup(path);
        return;
    }
    if (root->left) {
        path[d] = '0';
        build_codes(root->left, path, d + 1, codes);
    }
    if (root->right) {
        path[d] = '1';
        build_codes(root->right, path, d + 1, codes);
    }
}

void decode_huff(node *root, const char *s) {
    node *curr = root;
    for (size_t i = 0; s[i]; i++) {
        curr = (s[i] == '0') ? curr->left : curr->right;
        if (isLeaf(curr)) {
            putchar(curr->data);
            curr = root;
        }
    }
    putchar('\n');
}

int main() {
    char str[1000];
    scanf("%999s", str);

    int freq[256] = {0};
    for (int i = 0; str[i]; i++) freq[(unsigned char)str[i]]++;

    heap *h = heap_new(16);
    for (int i = 0; i < 256; i++) {
        if (freq[i] > 0) heap_push(h, newNode((char)i, freq[i], NULL, NULL));
    }

    while (h->n > 1) {
        node *l = heap_pop(h);
        node *r = heap_pop(h);
        heap_push(h, newNode('$', l->freq + r->freq, l, r));
    }
    node *root = heap_pop(h);

    char *codes[256] = {0}, path[256];
    build_codes(root, path, 0, codes);

    char encoded[10000] = "";
    for (int i = 0; str[i]; i++) strcat(encoded, codes[(unsigned char)str[i]]);

    decode_huff(root, encoded); // only decoded string is printed
    return 0;
}
